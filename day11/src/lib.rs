use std::cell::RefCell;
use std::collections::HashMap;
use std::rc::Rc;

fn split_num(num: u64) -> Vec<u64> {
    let digits = num_digits(num);

    let left = num / 10u64.pow(digits / 2);
    let right = num - (left * 10u64.pow(digits / 2));

    vec![left, right]
}

fn num_digits(num: u64) -> u32 {
    u64::ilog10(num) + 1
}

fn change_stone(num: u64) -> Vec<u64> {
    if num == 0 {
        return vec![1];
    }
    if num_digits(num) % 2 == 0 {
        return split_num(num);
    }
    vec![num * 2024]
}

type NodeRef = Rc<RefCell<Node>>;

#[derive(Debug)]
struct Node {
    num: u64,
    children: Vec<NodeRef>,
}

fn fill_cache(num: u64, cache: &mut HashMap<u64, NodeRef>) {
    // Check if the node already exists in the cache
    let node = match cache.get(&num) {
        Some(existing) => existing.clone(),
        None => {
            // If not: create a new empty node
            let new_node = Rc::new(RefCell::new(Node {
                num,
                children: Vec::new(),
            }));
            cache.insert(num, new_node.clone());
            new_node
        }
    };

    // If the node already has children, nothing to do.
    if !node.borrow().children.is_empty() {
        return;
    }

    // We have found an empty node, let's create some children
    let mut children = Vec::new();
    for child_num in change_stone(num) {
        // Since we're not currently holding a reference borrowed from get,
        // we can safely mutate the cache while we do this.
        let child_node = match cache.get(&child_num) {
            Some(child) => child.clone(),
            None => {
                let child_node = Rc::new(RefCell::new(Node {
                    num: child_num,
                    children: Vec::new(),
                }));
                cache.insert(child_num, child_node.clone());
                child_node
            }
        };
        children.push(child_node);
    }

    // Now safely update the current node.
    node.borrow_mut().children = children;
}

fn count(node: NodeRef, c: usize, cache: &mut HashMap<(u64, usize), u64>) -> u64 {
    // base case: we are the last node
    if c == 0 {
        return 1;
    }

    let node = node.borrow();
    let mut result = 0;

    // Ask each child if they have already computed the number of stones generated
    // when playing c - 1 times
    for child in node.children.clone() {
        let num = child.borrow().num;

        let count = match cache.get(&(num, c - 1)) {
            // If they do, great! we don't have to do the entire computation
            Some(count) => *count,
            // If they don't, then we'll need to ask the children of that node
            None => {
                // We'll do that recusively.. so try to get warp your head around it
                let count = count(child.clone(), c - 1, cache);
                // And cache the result to prevent future lookups
                cache.insert((num, c - 1), count);
                count
            }
        };

        // Add the total number of stones generated by the children to the result
        result += count;
    }

    result
}

pub fn partx(input: &str, target: usize) -> u64 {
    let nums = input
        .split_ascii_whitespace()
        .map(|num| num.parse::<u64>().unwrap())
        .collect::<Vec<_>>();

    let mut lookup: HashMap<u64, NodeRef> = HashMap::new();
    let mut count_lookup: HashMap<(u64, usize), u64> = HashMap::new();

    let mut result = 0;

    for num in nums.into_iter() {
        fill_cache(num, &mut lookup);

        for _ in 0..target {
            let keys: Vec<_> = lookup.keys().cloned().collect();
            for key in keys {
                fill_cache(key, &mut lookup);
            }
        }

        let node = lookup.get(&num).unwrap();
        result += count(node.clone(), target, &mut count_lookup);
    }

    result
}

pub fn part1(input: &str) -> u64 {
    partx(input, 25)
}

pub fn part2(input: &str) -> u64 {
    partx(input, 75)
}
